# 创建高性能的索引

## MySQL中最常用的索引类型
### B-tree索引
一般使用索引的时候都是用的B-tree索引（MySQL中用得更多的是B+树），本文以B+树为例进行讲解。

下图展示了B+树的结构：
![](assets/chapter7/1.svg)
B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，
使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。

#### 自适应哈希索引
InnoDB存储引擎有一个被称为**自适应哈希索引**的特性。当InnoDB发现某些索引值被非常频繁的访问时，他会在原有的B-tree索引上，在内存中再构建一个
自适应哈希索引。<br>
下面列出了可以使用B-tree索引的查询类型：
- 全值匹配：指的是和索引中的所有列匹配
- 匹配最左前缀：只使用索引的第一列
- 匹配列前缀：只匹配某一列的值的开头部分
- 匹配范围值
- 精确匹配某一列而范围匹配另一列
- 只访问索引的查询（覆盖索引）

#### 全文索引
全文索引是一种特殊类型的索引，它查找的时文本中的关键字，而不是直接比较索引中的值。<br>
它不是逐字节搜索，而是先把文本内容拆分成词（tokenize），再用倒排索引（Inverted Index）存储，类似搜索引擎的原理。  

## 高性能的索引策略
### 前缀索引和索引的选择性
有时候为了提升索引性能，同时也节省索引空间，可以只对字段的前一部分字符进行索引，这样做的缺点是，会降低索引的选择性。  
索引的选择性是指，**不重复的索引值和数据表的记录总数的比值**。  
一般情况下，列前缀的选择性也是足够高的，足以满足查询性能。对于BLOB、TEXT或者很长的VARCHAR类型的列，_必须_ 使用前缀索引。  

### 多列索引
在多列上单独创建多个单列索引，在大部分情况下并不能提高MySQL的查询性能。  
MySQL引入了一种叫“索引合并（index merge）”的策略，它在一定程度上可以使用表中的多个单列索引来定位指定的行。
- OR条件的联合（unio）
- AND条件的相交（intersection）
- 组合前两种情况的联合及相交

索引合并策略有时候效果非常不错，但更多的时候，它说明了表中的索引建得很糟糕：
- 当优化器需要对多个索引做相交操作时，通常意味着**需要一个包含所有相关列的多列索引**，而不是多个独立的单列索引
- 当优化器需要多多个索引做联合操作时，通常需要在算法的缓存、排序和合并操作上耗费大量CPU和内存资源
- 更重要的是，优化器不会把这些操作计算到“查询成本”当中，优化器只关心随机页面读取，这会使得查询的成本被“低估”，导致该执行计划还不如直接进行全表扫描。